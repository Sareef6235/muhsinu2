<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Welcome to My Portal - Neon Arcade</title>
  <style>
    :root {
      --cyan: #1de9ff;
      --purple: #c84cff;
      --bg1: #050509;
      --bg2: #0b1022;
      --text: #eaf6ff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Segoe UI", Roboto, Arial, sans-serif;
      background: radial-gradient(circle at 20% 20%, #111734 0%, var(--bg1) 40%, #020205 100%);
      color: var(--text);
    }

    #gameCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 2;
    }

    .title {
      position: absolute;
      top: clamp(10px, 3vh, 28px);
      left: 50%;
      transform: translateX(-50%);
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      text-align: center;
      font-size: clamp(1.1rem, 3vw, 2rem);
      color: #d9f8ff;
      text-shadow:
        0 0 8px rgba(29, 233, 255, 0.9),
        0 0 16px rgba(29, 233, 255, 0.75),
        0 0 28px rgba(200, 76, 255, 0.55);
      animation: glowTitle 2.6s ease-in-out infinite;
    }

    .scoreboard {
      position: absolute;
      top: clamp(10px, 2vh, 22px);
      right: clamp(10px, 2vw, 24px);
      text-align: right;
      font-size: clamp(0.9rem, 2vw, 1.15rem);
      line-height: 1.5;
      color: #ecf9ff;
      text-shadow: 0 0 8px rgba(29, 233, 255, 0.75);
      font-weight: 600;
      min-width: 120px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      z-index: 3;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    .panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      padding: 1.25rem 1.5rem;
      border-radius: 16px;
      background: rgba(10, 14, 29, 0.56);
      border: 1px solid rgba(29, 233, 255, 0.35);
      box-shadow:
        0 0 18px rgba(29, 233, 255, 0.18),
        0 0 32px rgba(200, 76, 255, 0.14),
        inset 0 0 30px rgba(12, 18, 40, 0.95);
      backdrop-filter: blur(4px);
      pointer-events: auto;
      min-width: min(80vw, 340px);
      text-align: center;
    }

    .panel h2 {
      font-size: clamp(1.2rem, 3vw, 1.9rem);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #f4f9ff;
      text-shadow:
        0 0 10px rgba(200, 76, 255, 0.9),
        0 0 20px rgba(29, 233, 255, 0.6);
    }

    .panel p {
      font-size: clamp(0.9rem, 2.4vw, 1rem);
      color: #cde8ff;
    }

    .neon-btn {
      border: 1px solid rgba(29, 233, 255, 0.8);
      color: #dffbff;
      background: linear-gradient(135deg, rgba(29, 233, 255, 0.18), rgba(200, 76, 255, 0.2));
      padding: 0.72rem 1.6rem;
      font-size: clamp(0.9rem, 2.2vw, 1rem);
      letter-spacing: 0.08em;
      border-radius: 999px;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: 600;
      transition: transform 0.2s ease, box-shadow 0.2s ease, filter 0.2s ease;
      box-shadow:
        0 0 10px rgba(29, 233, 255, 0.75),
        0 0 18px rgba(200, 76, 255, 0.45);
    }

    .neon-btn:hover,
    .neon-btn:focus-visible {
      transform: translateY(-1px) scale(1.02);
      filter: brightness(1.08);
      box-shadow:
        0 0 15px rgba(29, 233, 255, 0.95),
        0 0 26px rgba(200, 76, 255, 0.65);
      outline: none;
    }

    .hidden {
      display: none;
    }

    @keyframes glowTitle {
      0%,
      100% {
        filter: brightness(0.96);
      }
      50% {
        filter: brightness(1.24);
      }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" aria-label="Neon arcade game"></canvas>

  <div class="hud" aria-hidden="true">
    <h1 class="title">Welcome to My Portal</h1>
    <div class="scoreboard">
      <div id="scoreText">Score: 000</div>
      <div id="livesText">Lives: 3</div>
    </div>
  </div>

  <div class="overlay" id="startOverlay">
    <div class="panel">
      <h2>Neon Arcade</h2>
      <p>Move the paddle, keep all balls in play.</p>
      <button class="neon-btn" id="startBtn">Start Game</button>
    </div>
  </div>

  <div class="overlay hidden" id="gameOverOverlay">
    <div class="panel">
      <h2>Game Over</h2>
      <p id="finalScore">Final Score: 000</p>
      <button class="neon-btn" id="restartBtn">Restart</button>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      const scoreText = document.getElementById('scoreText');
      const livesText = document.getElementById('livesText');
      const startOverlay = document.getElementById('startOverlay');
      const gameOverOverlay = document.getElementById('gameOverOverlay');
      const finalScore = document.getElementById('finalScore');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');

      let w = 0;
      let h = 0;
      let running = false;
      let score = 0;
      let lives = 3;
      let gameSpeedFactor = 1;
      let lastTime = 0;
      let audioCtx;

      const paddle = {
        x: 0,
        y: 0,
        width: 130,
        height: 14,
        targetX: 0,
        glow: 0
      };

      const balls = [];
      const sparks = [];
      const bgParticles = [];
      const BALL_COUNT = 3;

      function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;

        paddle.width = Math.max(90, Math.min(170, w * 0.18));
        paddle.height = Math.max(12, Math.min(18, h * 0.02));
        paddle.y = h - Math.max(32, h * 0.08);
        paddle.x = (w - paddle.width) * 0.5;
        paddle.targetX = paddle.x;

        if (!bgParticles.length) {
          createBackgroundParticles();
        }
      }

      function createBackgroundParticles() {
        bgParticles.length = 0;
        const amount = Math.min(110, Math.floor((w * h) / 20000));
        for (let i = 0; i < amount; i++) {
          bgParticles.push({
            x: Math.random() * w,
            y: Math.random() * h,
            r: Math.random() * 1.8 + 0.4,
            vy: -(Math.random() * 0.15 + 0.05),
            alpha: Math.random() * 0.5 + 0.15,
            hue: Math.random() > 0.5 ? 190 : 285
          });
        }
      }

      function padScore(value) {
        return String(value).padStart(3, '0');
      }

      function randomBallColor() {
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 95%, 65%)`;
      }

      function resetBalls() {
        balls.length = 0;
        for (let i = 0; i < BALL_COUNT; i++) {
          const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.9;
          const speed = 230 + Math.random() * 70;
          balls.push({
            x: w * 0.35 + i * (w * 0.12),
            y: h * 0.35,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            r: Math.max(7, Math.min(11, w * 0.012)),
            color: randomBallColor()
          });
        }
      }

      function resetGame() {
        score = 0;
        lives = 3;
        gameSpeedFactor = 1;
        sparks.length = 0;
        updateHUD();
        resetBalls();
      }

      function updateHUD() {
        scoreText.textContent = `Score: ${padScore(score)}`;
        livesText.textContent = `Lives: ${lives}`;
      }

      function ensureAudioContext() {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
      }

      function playTone(type, frequency, duration, volume) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(frequency, now);
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + duration);
      }

      function playPaddleHit() {
        playTone('triangle', 480, 0.08, 0.045);
      }

      function playWallBounce() {
        playTone('sine', 280, 0.055, 0.03);
      }

      function playGameOverSound() {
        playTone('square', 180, 0.16, 0.05);
        setTimeout(() => playTone('square', 120, 0.24, 0.05), 120);
      }

      function createSparkBurst(x, y, color) {
        for (let i = 0; i < 14; i++) {
          const angle = (Math.PI * 2 * i) / 14 + Math.random() * 0.3;
          const speed = Math.random() * 120 + 70;
          sparks.push({
            x,
            y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.45 + Math.random() * 0.25,
            maxLife: 0.45 + Math.random() * 0.25,
            color
          });
        }
      }

      function loseLife(ball) {
        lives -= 1;
        updateHUD();

        if (lives <= 0) {
          running = false;
          finalScore.textContent = `Final Score: ${padScore(score)}`;
          gameOverOverlay.classList.remove('hidden');
          playGameOverSound();
          return;
        }

        const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.8;
        const speed = 250;
        ball.x = w * (0.2 + Math.random() * 0.6);
        ball.y = h * 0.34;
        ball.vx = Math.cos(angle) * speed;
        ball.vy = Math.sin(angle) * speed;
      }

      function update(dt) {
        gameSpeedFactor = Math.min(2.2, gameSpeedFactor + dt * 0.018);

        paddle.x += (paddle.targetX - paddle.x) * Math.min(1, 14 * dt);
        paddle.x = Math.max(0, Math.min(w - paddle.width, paddle.x));
        paddle.glow = Math.max(0, paddle.glow - dt * 2.8);

        for (const particle of bgParticles) {
          particle.y += particle.vy * 60 * dt;
          if (particle.y < -3) {
            particle.y = h + 3;
            particle.x = Math.random() * w;
          }
        }

        for (const ball of balls) {
          const speedMultiplier = gameSpeedFactor;
          ball.x += ball.vx * dt * speedMultiplier;
          ball.y += ball.vy * dt * speedMultiplier;

          if (ball.x - ball.r <= 0) {
            ball.x = ball.r;
            ball.vx *= -1;
            playWallBounce();
          } else if (ball.x + ball.r >= w) {
            ball.x = w - ball.r;
            ball.vx *= -1;
            playWallBounce();
          }

          if (ball.y - ball.r <= 0) {
            ball.y = ball.r;
            ball.vy *= -1;
            playWallBounce();
          }

          const paddleTop = paddle.y;
          const paddleBottom = paddle.y + paddle.height;
          const paddleRight = paddle.x + paddle.width;

          if (
            ball.y + ball.r >= paddleTop &&
            ball.y - ball.r <= paddleBottom &&
            ball.x >= paddle.x &&
            ball.x <= paddleRight &&
            ball.vy > 0
          ) {
            ball.y = paddleTop - ball.r;
            const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
            ball.vy = -Math.abs(ball.vy) * 1.02;
            ball.vx += hitPos * 80;

            const maxHorizontal = 520;
            ball.vx = Math.max(-maxHorizontal, Math.min(maxHorizontal, ball.vx));

            score += 1;
            paddle.glow = 1;
            updateHUD();
            createSparkBurst(ball.x, paddle.y, ball.color);
            playPaddleHit();
          }

          if (ball.y - ball.r > h) {
            loseLife(ball);
          }
        }

        for (let i = sparks.length - 1; i >= 0; i--) {
          const s = sparks[i];
          s.life -= dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
          s.vx *= 0.98;
          s.vy *= 0.98;
          if (s.life <= 0) sparks.splice(i, 1);
        }
      }

      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, w, h);
        gradient.addColorStop(0, '#05060d');
        gradient.addColorStop(0.5, '#080d1d');
        gradient.addColorStop(1, '#030307');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, w, h);

        for (const particle of bgParticles) {
          ctx.beginPath();
          ctx.fillStyle = `hsla(${particle.hue}, 100%, 70%, ${particle.alpha})`;
          ctx.shadowBlur = 10;
          ctx.shadowColor = `hsla(${particle.hue}, 100%, 70%, 0.8)`;
          ctx.arc(particle.x, particle.y, particle.r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;
      }

      function drawPaddle() {
        const pulse = 0.45 + paddle.glow * 0.9;
        const grad = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x + paddle.width, paddle.y + paddle.height);
        grad.addColorStop(0, 'rgba(29, 233, 255, 0.95)');
        grad.addColorStop(1, 'rgba(200, 76, 255, 0.95)');

        ctx.save();
        ctx.fillStyle = grad;
        ctx.shadowBlur = 16 + paddle.glow * 26;
        ctx.shadowColor = `rgba(29, 233, 255, ${pulse})`;
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        ctx.restore();
      }

      function drawBalls() {
        for (const ball of balls) {
          ctx.save();
          ctx.fillStyle = ball.color;
          ctx.shadowBlur = 20;
          ctx.shadowColor = ball.color;
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      function drawSparks() {
        for (const s of sparks) {
          const alpha = Math.max(0, s.life / s.maxLife);
          ctx.save();
          ctx.fillStyle = s.color.replace('hsl', 'hsla').replace(')', `, ${alpha})`);
          ctx.shadowBlur = 8;
          ctx.shadowColor = s.color;
          ctx.beginPath();
          ctx.arc(s.x, s.y, 2.2, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      function render() {
        drawBackground();
        drawPaddle();
        drawBalls();
        drawSparks();
      }

      function gameLoop(time) {
        const now = time * 0.001;
        const dt = Math.min(0.033, now - lastTime || 0.016);
        lastTime = now;

        if (running) {
          update(dt);
        }
        render();
        requestAnimationFrame(gameLoop);
      }

      function setPaddleByClientX(clientX) {
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        paddle.targetX = x - paddle.width / 2;
      }

      canvas.addEventListener('mousemove', (event) => {
        setPaddleByClientX(event.clientX);
      });

      canvas.addEventListener('touchmove', (event) => {
        if (event.touches.length > 0) {
          setPaddleByClientX(event.touches[0].clientX);
        }
      }, { passive: true });

      startBtn.addEventListener('click', () => {
        ensureAudioContext();
        resetGame();
        running = true;
        startOverlay.classList.add('hidden');
        gameOverOverlay.classList.add('hidden');
      });

      restartBtn.addEventListener('click', () => {
        ensureAudioContext();
        resetGame();
        running = true;
        gameOverOverlay.classList.add('hidden');
      });

      window.addEventListener('resize', () => {
        resize();
        createBackgroundParticles();
      });

      resize();
      resetGame();
      render();
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>
